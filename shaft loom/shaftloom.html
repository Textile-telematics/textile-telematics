<!-- Distributed under the terms of the AGPLv3 -->
<!-- Distributed under the terms of the AGPLv3 -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>MQTT Weaving Draft</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <script src="https://unpkg.com/mathjs@11/lib/browser/math.js"></script>

    <style>
        input[type="checkbox"] {
            width: 20px;
            height: 20px;
        }

        .cell {
            width: 20px;
            height: 20px;
            border: 1px solid #aaa;
        }

        .up {
            background: black;
        }

        .indicator {
            width: 20px;
            height: 20px;
            border: 1px solid red;
        }

        .active {
            background: red;
        }
    </style>
</head>

<body class="bg-gray-50 text-gray-900 p-4 font-sans">

    <!-- ================= HEADER ================= -->
    <header class="mb-4">
        <h2 class="text-2xl font-semibold mb-3">Weaving Draft</h2>

        <div class="flex flex-wrap gap-2 items-center">
            <button id="testMode" class="px-3 py-1 bg-red-600 text-white rounded">Enter Test Mode</button>
            <button id="standardMode" class="px-3 py-1 bg-red-600 text-white rounded hidden">Enter Standard Mode</button>
            <button id="footswitchTest" class="px-3 py-1 bg-red-600 text-white rounded hidden">Foodswitch</button>
            <button id="caStart" class="px-3 py-1 bg-red-600 text-white rounded hidden">CA Start</button>
            <button id="caStop" class="px-3 py-1 bg-red-600 text-white rounded hidden">CA Stop</button>
            <button id="sendPick" class="px-3 py-1 bg-blue-600 text-white rounded">Send</button>
            <button id="prevPick" class="px-3 py-1 bg-gray-700 text-white rounded">Prev</button>
            <button id="nextPick" class="px-3 py-1 bg-gray-700 text-white rounded">Next</button>

            <div class="ml-4 flex gap-2 items-center">
                <button id="saveWIF" class="px-3 py-1 bg-gray-900 text-white rounded">Save</button>
                <input type="file" id="loadWIF" accept=".txt"
                    class="text-sm file:bg-gray-200 file:px-2 file:py-1 file:rounded">
            </div>
        </div>
    </header>

    <!-- ================= DRAFT ================= -->
    <main class="grid grid-cols-[auto_1fr] gap-6 items-start">

        <!-- LEFT COLUMN -->
        <div class="flex flex-col gap-6">

            <section>
                <h3 class="font-semibold mb-1">Tie-Up</h3>
                <div id="tieup" class="grid gap-[3px]"></div>
            </section>

            <section>
                <h3 class="font-semibold mb-1">Treadling</h3>
                <div id="treadling" class="grid gap-[3px]"></div>
            </section>
        </div>

        <!-- RIGHT COLUMN -->
        <div class="flex flex-col gap-6 overflow-auto">

            <section>
                <h3 class="font-semibold mb-1">Threading</h3>
                <div id="threading" class="grid gap-[3px]"></div>
            </section>

            <section>
                <h3 class="font-semibold mb-1">Drawdown</h3>
                <div id="drawdown" class="grid gap-[3px]"></div>
            </section>

        </div>

        <section class="col-span-2 bg-gray-100 rounded-lg p-4 space-y-4">
            <details class="bg-white border rounded p-3">
                <summary class="font-semibold cursor-pointer">Expressions</summary>

                <div class="mt-3 space-y-3 text-sm">
                    <div>
                        <label class="block font-medium">Threading (w)</label>
                        <input id="exprThreading" class="border px-2 py-1 w-full font-mono" value="w">
                        <button id="applyThreading" class="mt-1 px-2 py-1 bg-blue-600 text-white rounded">Apply</button>
                    </div>

                    <div>
                        <label class="block font-medium">Tie-up (t, s)</label>
                        <input id="exprTieup" class="border px-2 py-1 w-full font-mono" value="(s+t)%2">
                        <button id="applyTieup" class="mt-1 px-2 py-1 bg-blue-600 text-white rounded">Apply</button>
                    </div>

                    <div>
                        <label class="block font-medium">Treadling (p, t)</label>
                        <input id="exprTreadling" class="border px-2 py-1 w-full font-mono" value="(p+t)%2">
                        <button id="applyTreadling" class="mt-1 px-2 py-1 bg-blue-600 text-white rounded">Apply</button>
                    </div>
                </div>
            </details>

            <details class="bg-white border rounded p-3">
                <summary class="font-semibold cursor-pointer">Copy + Paste</summary>

                <div class="mt-3 space-y-3 text-sm">
                    <div>
                        <label class="block font-medium">Threading</label>
                        <textarea id="txtThreading" class="w-full border font-mono text-xs p-1 h-20"></textarea>
                        <button id="applyTxtThreading"
                            class="mt-1 px-2 py-1 bg-gray-800 text-white rounded">Apply</button>
                    </div>

                    <div>
                        <label class="block font-medium">Tie-Up</label>
                        <textarea id="txtTieup" class="w-full border font-mono text-xs p-1 h-16"></textarea>
                        <button id="applyTxtTieup" class="mt-1 px-2 py-1 bg-gray-800 text-white rounded">Apply</button>
                    </div>

                    <div>
                        <label class="block font-medium">Treadling</label>
                        <textarea id="txtTreadling" class="w-full border font-mono text-xs p-1 h-16"></textarea>
                        <button id="applyTxtTreadling"
                            class="mt-1 px-2 py-1 bg-gray-800 text-white rounded">Apply</button>
                    </div>
                </div>
            </details>
        </section>

    </main>


    <script>
        /* ================= CONFIG ================= */
        let params = new URLSearchParams(document.location.search);
        const SHAFTS = parseInt(params.get("shafts")) || 8;
        const TREADLES = parseInt(params.get("treadles")) || 8;
        const PICKS = parseInt(params.get("picks")) || 12;
        const WARPS = parseInt(params.get("warps")) || 32;

        let active_weft = PICKS-1;

        // test mode off by default
        let testmode_status = false;
        let testmode_prefix = "";

        let drawdown_rows = [];

        // const MQTT_URL = 'wss://slab.org:8883/mqtt';
        const MQTT_URL = 'ws://slab.org:8083/mqtt';
        const TOPIC = 'weaving/draft/full';
        let mqtt_password = undefined;
        let password_entered = false;

        const cookie = /mqtt_pass=(\w+)/.exec(window.document.cookie);
        if (cookie) {
            mqtt_password = cookie[1];
        }
        if (typeof password === 'undefined') {
            mqtt_password = prompt('Please enter MQTT server password');
            password_entered = true;
        }

        /* ================= MQTT ================= */
        const client = mqtt.connect(MQTT_URL, { username: "alpaca", password: mqtt_password });
        client.on('connect', () => {
            client.subscribe(TOPIC);
            client.subscribe("tc2/footswitch");
            client.subscribe(("test/"+TOPIC));
            client.subscribe("test/tc2/footswitch");
            client.subscribe("test/ca/start");
            client.subscribe("ca/start");
            client.subscribe("test/ca/stop");
            client.subscribe("ca/stop");
            if (password_entered) {
                document.cookie = 'mqtt_pass=' + mqtt_password;
            }

        });

        client.on('disconnect', x => console.log("disconnect: " + x));
        /* ================= DATA ================= */
        /* threading[warp][shaft] */
        let threading = Array.from({ length: WARPS }, () => Array(SHAFTS).fill(0));
        let tieup = Array.from({ length: SHAFTS }, () => Array(TREADLES).fill(0));
        let treadling = Array.from({ length: PICKS }, () => Array(TREADLES).fill(0));

        /* --- default plain weave --- */
        for (let w = 0; w < WARPS; w++) threading[w][w % 2] = 1;
        for (let t = 0; t < TREADLES; t++) tieup[t % 2][t] = 1;
        for (let p = 0; p < PICKS; p++) treadling[p][p % 2] = 1;

        /* ================= HELPERS ================= */
        function publish() {
            console.log("testmode_Prefix:"+testmode_prefix);
            client.publish((testmode_prefix+TOPIC), JSON.stringify({ threading, tieup, treadling }));
        }

        function onDraftChange() {
            publish();
            drawDrawdown();
        }

        /* ================= THREADING (SHAFTS Ã— WARPS) ================= */
        function buildThreading(container) {
            container.innerHTML = '';
            container.style.gridTemplateColumns = `repeat(${WARPS}, 20px)`;

            for (let s = 0; s < SHAFTS; s++) {
                for (let w = 0; w < WARPS; w++) {
                    const cb = document.createElement('input');
                    cb.type = 'checkbox';
                    cb.checked = !!threading[w][s];

                    cb.onchange = () => {
                        for (let i = 0; i < SHAFTS; i++) threading[w][i] = 0;
                        threading[w][s] = cb.checked ? 1 : 0;
                        onDraftChange();
                    };

                    container.appendChild(cb);
                }
            }
        }

        /* ================= GENERIC GRID ================= */
        function buildGrid(container, rows, cols, data) {
            container.innerHTML = '';
            container.style.gridTemplateColumns = `repeat(${cols}, 20px)`;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cb = document.createElement('input');
                    cb.type = 'checkbox';
                    cb.checked = !!data[r][c];

                    cb.onchange = () => {
                        data[r][c] = cb.checked ? 1 : 0;
                        onDraftChange();
                    };

                    container.appendChild(cb);
                }
            }
        }

        /* ================= DRAW DOWN ================= */
        function drawDrawdown() {
            drawdown.innerHTML = '';
            drawdown.style.gridTemplateColumns = `repeat(${WARPS + 1}, 20px)`;
            drawdown_rows = [];
            for (let p = 0; p < PICKS; p++) {
                let drawdown_row = "";
                for (let w = 0; w < WARPS; w++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';

                    let lifted = false;

                    for (let t = 0; t < TREADLES; t++) {
                        if (!treadling[p][t]) continue;

                        for (let s = 0; s < SHAFTS; s++) {
                            if (threading[w][s] && tieup[s][t]) {
                                lifted = true;
                            }
                        }
                    }

                    if (lifted) {
                        cell.classList.add('up');
                        drawdown_row += "1";
                    }
                    else {
                        drawdown_row += "0";
                    }
                    drawdown.appendChild(cell);
                }
                const indicator = document.createElement('div');
                indicator.className = 'indicator';
                indicator.id = "indicator" + p;

                drawdown.appendChild(indicator);
                drawdown_rows.push(drawdown_row);
            }
            update_active();
        }

        // Actions

        function update_active() {
            // const active = (PICKS - active_weft - 1) % PICKS;
            const active = active_weft;
            for (let i = 0; i < PICKS; ++i) {
                const indicator = document.getElementById("indicator" + i);
                if (i == active) {
                    indicator.classList.add("active");
                }
                else {
                    indicator.classList.remove("active");
                }
            }
        }

        function advance(i) {
            active_weft -= i;
            active_weft = ((active_weft % PICKS) + PICKS) % PICKS;
            update_active();
        }

        function footswitch_test(){
            client.publish((testmode_prefix+"tc2/footswitch"))
            // advance(1);
            // send_active();
        }

        function test_mode(set_testmode){
            if(set_testmode){
                testmode_status = true;
                testmode_prefix = "test/";
                document.getElementById("footswitchTest").classList.toggle("hidden", false);
                document.getElementById("standardMode").classList.toggle("hidden", false);
                document.getElementById("testMode").classList.add("hidden");
                document.getElementById("caStart").classList.toggle("hidden", false);
                document.getElementById("caStop").classList.add("hidden");
            }else{
                testmode_status = false;
                testmode_prefix = "";
                ca_activate(false); //stop the CA if it's running
                document.getElementById("footswitchTest").classList.toggle("hidden", true);
                document.getElementById("standardMode").classList.toggle("hidden", true);
                document.getElementById("testMode").classList.toggle("hidden", false);
                document.getElementById("caStart").classList.toggle("hidden", true);
                document.getElementById("caStop").classList.toggle("hidden", true);
            }

        }

        function ca_activate(ca_status){
            if(ca_status){
                publish(); //push the current pattern to CA
                client.publish((testmode_prefix+"ca/start"));
                document.getElementById("caStart").classList.toggle("hidden", true);
                document.getElementById("caStop").classList.toggle("hidden", false);
            }else{
                client.publish((testmode_prefix+"ca/stop"));
                document.getElementById("caStart").classList.toggle("hidden", false);
                document.getElementById("caStop").classList.toggle("hidden", true);
            }

        }

        function send_active() {
            const total_ends = 1320;
            let pattern = drawdown_rows[active_weft];
            const repeats = Math.floor(total_ends / pattern.length)
            const selvedge = (total_ends - (repeats * pattern.length)) / 2;
            //const left = Array.from({ length: Math.floor(selvedge) }, (_, i) => 1).join(""); //for debugging
            const left = Array.from({ length: Math.floor(selvedge) }, (_, i) => (i + active_weft) % 2).join("");
            //const right = Array.from({ length: Math.ceil(selvedge) }, (_, i) => 1).join(""); //for debugging
            const right = Array.from({ length: Math.ceil(selvedge) }, (_, i) => (i + active_weft) % 2).join("");

            const pick = left + pattern.repeat(repeats) + right;
            // console.log("length: " + pick.length)
            // console.log("left: " + left);
            // console.log("right: " + right);
            // console.log("repeats: " + repeats);
            // console.log("selvedge: " + selvedge);
            console.log("sending: " + pick);
            client.publish((testmode_prefix+"pattern"), pick);
        }

        // Convert grid data to WIF string
        function exportWIF() {
            function serialize(grid) {
                return grid.map(row => row.join(',')).join(';');
            }

            return `<draft>
<shafts>${SHAFTS}</shafts>
<treadles>${TREADLES}</treadles>
<warps>${WARPS}</warps>
<picks>${PICKS}</picks>
<threading>${serialize(threading)}</threading>
<tieup>${serialize(tieup)}</tieup>
<treadling>${serialize(treadling)}</treadling>
</draft>`;
        }

        // Parse WIF string and populate data
        function importWIF(wifText) {
            function parseGrid(str) {
                return str.trim().split(';').map(row => row.split(',').map(Number));
            }

            const threadingMatch = wifText.match(/<threading>([\s\S]*?)<\/threading>/);
            const tieupMatch = wifText.match(/<tieup>([\s\S]*?)<\/tieup>/);
            const treadlingMatch = wifText.match(/<treadling>([\s\S]*?)<\/treadling>/);

            if (threadingMatch && tieupMatch && treadlingMatch) {
                threading = parseGrid(threadingMatch[1]);
                tieup = parseGrid(tieupMatch[1]);
                treadling = parseGrid(treadlingMatch[1]);

                buildThreading(threadingDiv);
                buildGrid(tieupDiv, SHAFTS, TREADLES, tieup);
                buildGrid(treadlingDiv, PICKS, TREADLES, treadling);
                publish(); //push to other clients
                drawDrawdown();
            } else {
                alert("Invalid WIF file");
            }
        }

        document.getElementById('footswitchTest').onclick = () => {
            footswitch_test();
        };
        document.getElementById('testMode').onclick = () => {
            test_mode(true);
        };
        document.getElementById('standardMode').onclick = () => {
            test_mode(false);
        };
        document.getElementById('caStart').onclick = () => {
            ca_activate(true);
        };
        document.getElementById('caStop').onclick = () => {
            ca_activate(false);

        };
        document.getElementById('sendPick').onclick = () => {
            send_active();
        };
        document.getElementById('nextPick').onclick = () => {
            advance(1)
            // send_active();
        };
        document.getElementById('prevPick').onclick = () => {
            advance(-1)
            // send_active();
        };

        document.getElementById('applyThreading').onclick = () => {
            const expr = document.getElementById('exprThreading').value;

            try {
                for (let w = 0; w < WARPS; w++) {
                    const val = math.evaluate(expr, { w, PICKS, WARPS, SHAFTS });
                    const shaft = Math.abs(Math.floor(val)) % SHAFTS;
                    threading[w].fill(0);
                    threading[w][shaft] = 1;
                }
                buildThreading(threadingDiv);
                onDraftChange();
            } catch (e) {
                alert('Invalid expression');
            }
        };

        document.getElementById('applyTieup').onclick = () => {
            try {
                for (let t = 0; t < TREADLES; t++)
                    for (let s = 0; s < SHAFTS; s++)
                        tieup[t][s] = !!math.evaluate(exprTieup.value, { t, s });
                buildGrid(tieupDiv, TREADLES, SHAFTS, tieup);
                onDraftChange();
            } catch { alert('Tie-up expression error'); }
        };

        document.getElementById('applyTreadling').onclick = () => {
            try {
                for (let p = 0; p < PICKS; p++)
                    for (let t = 0; t < TREADLES; t++)
                        treadling[p][t] = !!math.evaluate(exprTreadling.value, { p, t });
                buildGrid(treadlingDiv, PICKS, TREADLES, treadling);
                onDraftChange();
            } catch { alert('Treadling expression error'); }
        };

        // Save WIF
        document.getElementById('saveWIF').onclick = () => {
            const wif = exportWIF();
            const blob = new Blob([wif], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'draft.txt';
            a.click();
            URL.revokeObjectURL(url);
        };

        // Load WIF
        document.getElementById('loadWIF').onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (evt) => importWIF(evt.target.result);
            reader.readAsText(file);
        };

        function parse01Grid(text, rows, cols) {
            const lines = text.trim().split(/\r?\n/).map(l => l.replace(/\D/g, '')).filter(Boolean);
            // if (lines.length !== rows) throw 'Row count mismatch';
            window.lines = lines;
            return lines.map(line => {
                const vals = line.split('').map(v => v.trim());
                // if (vals.length !== cols) throw 'Column count mismatch';
                return vals.map(v => v === '1' ? 1 : 0);
            });
        }

        applyTxtThreading.onclick = () => {
            // try {
            const grid = parse01Grid(txtThreading.value, SHAFTS, WARPS);

            for (let w = 0; w < WARPS; w++) {
                threading[w].fill(0);
                for (let s = 0; s < SHAFTS; s++) {
                    try {
                        if (grid[s][w]) {
                            threading[w][s] = 1;
                            break; // enforce one shaft per warp
                        }
                    }
                    catch (e) {

                    }
                }
            }

            buildThreading(threadingDiv);
            onDraftChange();
            // } catch (e) {
            //     alert('Invalid threading grid', e);
            // }
        };

        applyTxtTieup.onclick = () => {
            try {
                tieup = parse01Grid(txtTieup.value, SHAFTS, TREADLES);
                buildGrid(tieupDiv, SHAFTS, TREADLES, tieup);
                onDraftChange();
            } catch (e) {
                alert('Invalid tie-up grid');
            }
        };

        applyTxtTreadling.onclick = () => {
            try {
                treadling = parse01Grid(txtTreadling.value, PICKS, TREADLES);
                buildGrid(treadlingDiv, PICKS, TREADLES, treadling);
                onDraftChange();
            } catch (e) {
                alert('Invalid treadling grid');
            }
        };

        /* ================= INIT ================= */
        const threadingDiv = document.getElementById('threading');
        const tieupDiv = document.getElementById('tieup');
        const treadlingDiv = document.getElementById('treadling');
        const drawdown = document.getElementById('drawdown');

        buildThreading(threadingDiv);
        buildGrid(tieupDiv, SHAFTS, TREADLES, tieup);
        buildGrid(treadlingDiv, PICKS, TREADLES, treadling);
        drawDrawdown();

        /* ================= MQTT RECEIVE ================= */
        client.on('message', (topic, msg) => {

            if (topic == (testmode_prefix+"weaving/draft/full")) {
                const data = JSON.parse(msg.toString());
                if (!data.threading) return;

                threading = data.threading;
                tieup = data.tieup;
                treadling = data.treadling;

                buildThreading(threadingDiv);
                buildGrid(tieupDiv, SHAFTS, TREADLES, tieup);
                buildGrid(treadlingDiv, PICKS, TREADLES, treadling);
                drawDrawdown();
            }
            else if (topic == (testmode_prefix+"tc2/footswitch")) {
                console.log("footswitch!")
                advance(1);
                send_active();
            }
        });
    </script>
</body>

</html>