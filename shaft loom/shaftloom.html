<!-- Distributed under the terms of the AGPLv3 -->
<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>MQTT Weaving Draft</title>

    <style>
        body {
            font-family: sans-serif;
        }

        h3 {
            margin: 4px 0;
        }

        /* --- Overall draft layout --- */
        #draft {
            display: grid;
            grid-template-columns: auto 1fr;
            grid-template-rows: auto 1fr;
            gap: 16px;
            align-items: start;
        }

        .grid {
            display: grid;
            gap: 3px;
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            border: 0;
            margin: 1px;
        }

        .cell {
            width: 20px;
            height: 20px;
            border: 1px solid #aaa;
        }

        .indicator {
            width: 20px;
            height: 20px;
            border: 1px solid #f00;
        }

        .active {
            width: 20px;
            height: 20px;
            border: 1px solid #f00;
            background-color: #f00;
        }

        .up {
            background: black;
        }
    </style>
</head>

<body>

    <h2>Weaving Draft</h2>

    <div id="draft">

        <!-- Top Left -->
        <div>
            <h3>Tie-Up</h3>
            <div id="tieup" class="grid"></div>
        </div>

        <!-- Top Right -->
        <div>
            <h3>Threading</h3>
            <div id="threading" class="grid"></div>
        </div>

        <!-- Bottom Left -->
        <div>
            <h3>Treadling</h3>
            <div id="treadling" class="grid"></div>
        </div>

        <!-- Bottom Right -->
        <div>
            <h3>Drawdown</h3>
            <div id="drawdown" class="grid"></div>
        </div>

    </div>
    <hr />
    <div>
        <button id="sendPick">Send</button>
        <button id="prevPick">Prev</button>
        <button id="nextPick">Next</button>
    </div>
    <div>
        <button id="saveWIF">Save</button>
        <input type="file" id="loadWIF" accept=".txt">
    </div>
    <hr />
    <div>
        <details>
            <summary>Expressions</summary>
            Threading expression (w):<br />
            <input id="exprThreading" type="text" value="w">
            <button id="applyThreading">Apply</button><br> <br />
            e.g.:
            <ul>
                <li>direct threading: w</li>
                <li>point threading: abs((w%((SHAFTS-1)*2))-(SHAFTS-1))</li>
            </ul>

            Tie-up expression (t, s):<br />
            <input id="exprTieup" type="text" value="(s+t)%2">
            <button id="applyTieup">Apply</button><br>

            Treadling expression (p, t):<br />
            <input id="exprTreadling" type="text" value="(p+t)%2">
            <button id="applyTreadling">Apply</button>
        </details>
        <details>
            <summary>Copy+Paste</summary>
            <br><br>
            <b>Paste 0/1 grids</b><br>

            Threading (shafts × warps):<br>
            <textarea id="txtThreading" rows="4" cols="60"></textarea>
            <button id="applyTxtThreading">Apply</button><br><br>

            Tie-up (treadles × shafts):<br>
            <textarea id="txtTieup" rows="4" cols="40"></textarea>
            <button id="applyTxtTieup">Apply</button><br><br>

            Treadling (picks × treadles):<br>
            <textarea id="txtTreadling" rows="4" cols="40"></textarea>
            <button id="applyTxtTreadling">Apply</button>
        </details>

    </div>
    <script>
        /* ================= CONFIG ================= */
        let params = new URLSearchParams(document.location.search);
        const SHAFTS = parseInt(params.get("shafts")) || 8;
        const TREADLES = parseInt(params.get("treadles")) || 8;
        const PICKS = parseInt(params.get("picks")) || 12;
        const WARPS = parseInt(params.get("warps")) || 32;

        let active_weft = 0;

        let drawdown_rows = [];

        // const MQTT_URL = 'wss://slab.org:8883/mqtt';
        const MQTT_URL = 'ws://slab.org:8083/mqtt';
        const TOPIC = 'weaving/draft/full';
        let mqtt_password = undefined;
        let password_entered = false;

        const cookie = /mqtt_pass=(\w+)/.exec(window.document.cookie);
        if (cookie) {
            mqtt_password = cookie[1];
        }
        if (typeof password === 'undefined') {
            mqtt_password = prompt('Please enter MQTT server password');
            password_entered = true;
        }

        /* ================= MQTT ================= */
        const client = mqtt.connect(MQTT_URL, { username: "alpaca", password: mqtt_password });
        client.on('connect', () => {
            client.subscribe(TOPIC);
            client.subscribe("/tc2/footswitch")
            if (password_entered) {
                document.cookie = 'mqtt_pass=' + mqtt_password;
            }

        });

        client.on('disconnect', x => console.log("disconnect: " + x));
        /* ================= DATA ================= */
        /* threading[warp][shaft] */
        let threading = Array.from({ length: WARPS }, () => Array(SHAFTS).fill(0));
        let tieup = Array.from({ length: SHAFTS }, () => Array(TREADLES).fill(0));
        let treadling = Array.from({ length: PICKS }, () => Array(TREADLES).fill(0));

        /* --- default plain weave --- */
        for (let w = 0; w < WARPS; w++) threading[w][w % 2] = 1;
        for (let t = 0; t < TREADLES; t++) tieup[t % 2][t] = 1;
        for (let p = 0; p < PICKS; p++) treadling[p][p % 2] = 1;

        /* ================= HELPERS ================= */
        function publish() {
            client.publish(TOPIC, JSON.stringify({ threading, tieup, treadling }));
        }

        function onDraftChange() {
            publish();
            drawDrawdown();
        }

        /* ================= THREADING (SHAFTS × WARPS) ================= */
        function buildThreading(container) {
            container.innerHTML = '';
            container.style.gridTemplateColumns = `repeat(${WARPS}, 20px)`;

            for (let s = 0; s < SHAFTS; s++) {
                for (let w = 0; w < WARPS; w++) {
                    const cb = document.createElement('input');
                    cb.type = 'checkbox';
                    cb.checked = !!threading[w][s];

                    cb.onchange = () => {
                        for (let i = 0; i < SHAFTS; i++) threading[w][i] = 0;
                        threading[w][s] = cb.checked ? 1 : 0;
                        onDraftChange();
                    };

                    container.appendChild(cb);
                }
            }
        }

        /* ================= GENERIC GRID ================= */
        function buildGrid(container, rows, cols, data) {
            container.innerHTML = '';
            container.style.gridTemplateColumns = `repeat(${cols}, 20px)`;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cb = document.createElement('input');
                    cb.type = 'checkbox';
                    cb.checked = !!data[r][c];

                    cb.onchange = () => {
                        data[r][c] = cb.checked ? 1 : 0;
                        onDraftChange();
                    };

                    container.appendChild(cb);
                }
            }
        }

        /* ================= DRAW DOWN ================= */
        function drawDrawdown() {
            drawdown.innerHTML = '';
            drawdown.style.gridTemplateColumns = `repeat(${WARPS + 1}, 20px)`;
            drawdown_rows = [];
            for (let p = 0; p < PICKS; p++) {
                let drawdown_row = "";
                for (let w = 0; w < WARPS; w++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';

                    let lifted = false;

                    for (let t = 0; t < TREADLES; t++) {
                        if (!treadling[p][t]) continue;

                        for (let s = 0; s < SHAFTS; s++) {
                            if (threading[w][s] && tieup[s][t]) {
                                lifted = true;
                            }
                        }
                    }

                    if (lifted) {
                        cell.classList.add('up');
                        drawdown_row += "1";
                    }
                    else {
                        drawdown_row += "0";
                    }
                    drawdown.appendChild(cell);
                }
                const indicator = document.createElement('div');
                indicator.className = 'indicator';
                indicator.id = "indicator" + p;

                drawdown.appendChild(indicator);
                drawdown_rows.push(drawdown_row);
            }
            update_active();
        }

        function update_active() {
            const active = (PICKS - active_weft - 1) % PICKS;
            for (let i = 0; i < PICKS; ++i) {
                const indicator = document.getElementById("indicator" + i);
                if (i == active) {
                    indicator.classList.add("active");
                }
                else {
                    indicator.classList.remove("active");
                }
            }
        }

        function advance(i) {
            active_weft += i;
            active_weft = active_weft % PICKS;
            update_active();
        }

        function send_active() {
            const total_ends = 1320;
            let pattern = drawdown_rows[active_weft];
            const repeats = Math.floor(total_ends / pattern.length)
            const selvedge = (total_ends - (repeats * pattern.length)) / 2;
            const left = Array.from({ length: Math.floor(selvedge) }, (_, i) => (i + active_weft) % 2).join("");
            const right = Array.from({ length: Math.ceil(selvedge) }, (_, i) => (i + active_weft) % 2).join("");
            const pick = left + pattern.repeat(repeats) + right;
            // console.log("length: " + pick.length)
            // console.log("left: " + left);
            // console.log("right: " + right);
            // console.log("repeats: " + repeats);
            // console.log("selvedge: " + selvedge);
            console.log("sending: " + pick);
            client.publish("/pattern", pick);
        }

        // Convert grid data to WIF string
        function exportWIF() {
            function serialize(grid) {
                return grid.map(row => row.join(',')).join(';');
            }

            return `<draft>
<shafts>${SHAFTS}</shafts>
<treadles>${TREADLES}</treadles>
<warps>${WARPS}</warps>
<picks>${PICKS}</picks>
<threading>${serialize(threading)}</threading>
<tieup>${serialize(tieup)}</tieup>
<treadling>${serialize(treadling)}</treadling>
</draft>`;
        }

        // Parse WIF string and populate data
        function importWIF(wifText) {
            function parseGrid(str) {
                return str.trim().split(';').map(row => row.split(',').map(Number));
            }

            const threadingMatch = wifText.match(/<threading>([\s\S]*?)<\/threading>/);
            const tieupMatch = wifText.match(/<tieup>([\s\S]*?)<\/tieup>/);
            const treadlingMatch = wifText.match(/<treadling>([\s\S]*?)<\/treadling>/);

            if (threadingMatch && tieupMatch && treadlingMatch) {
                threading = parseGrid(threadingMatch[1]);
                tieup = parseGrid(tieupMatch[1]);
                treadling = parseGrid(treadlingMatch[1]);

                buildThreading(threadingDiv);
                buildGrid(tieupDiv, SHAFTS, TREADLES, tieup);
                buildGrid(treadlingDiv, PICKS, TREADLES, treadling);
                drawDrawdown();
            } else {
                alert("Invalid WIF file");
            }
        }

        document.getElementById('sendPick').onclick = () => {
            send_active();
        };
        document.getElementById('nextPick').onclick = () => {
            advance(1)
            // send_active();
        };
        document.getElementById('prevPick').onclick = () => {
            advance(-1)
            // send_active();
        };

        document.getElementById('applyThreading').onclick = () => {
            const expr = document.getElementById('exprThreading').value;

            try {
                for (let w = 0; w < WARPS; w++) {
                    const val = math.evaluate(expr, { w, PICKS, WARPS, SHAFTS });
                    const shaft = Math.abs(Math.floor(val)) % SHAFTS;
                    threading[w].fill(0);
                    threading[w][shaft] = 1;
                }
                buildThreading(threadingDiv);
                onDraftChange();
            } catch (e) {
                alert('Invalid expression');
            }
        };

        document.getElementById('applyTieup').onclick = () => {
            try {
                for (let t = 0; t < TREADLES; t++)
                    for (let s = 0; s < SHAFTS; s++)
                        tieup[t][s] = !!math.evaluate(exprTieup.value, { t, s });
                buildGrid(tieupDiv, TREADLES, SHAFTS, tieup);
                onDraftChange();
            } catch { alert('Tie-up expression error'); }
        };

        document.getElementById('applyTreadling').onclick = () => {
            try {
                for (let p = 0; p < PICKS; p++)
                    for (let t = 0; t < TREADLES; t++)
                        treadling[p][t] = !!math.evaluate(exprTreadling.value, { p, t });
                buildGrid(treadlingDiv, PICKS, TREADLES, treadling);
                onDraftChange();
            } catch { alert('Treadling expression error'); }
        };

        // Save WIF
        document.getElementById('saveWIF').onclick = () => {
            const wif = exportWIF();
            const blob = new Blob([wif], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'draft.txt';
            a.click();
            URL.revokeObjectURL(url);
        };

        // Load WIF
        document.getElementById('loadWIF').onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (evt) => importWIF(evt.target.result);
            reader.readAsText(file);
        };

        function parse01Grid(text, rows, cols) {
            const lines = text.trim().split(/\r?\n/).map(l => l.replace(/\D/g, '')).filter(Boolean);
            // if (lines.length !== rows) throw 'Row count mismatch';
            window.lines = lines;
            return lines.map(line => {
                const vals = line.split('').map(v => v.trim());
                // if (vals.length !== cols) throw 'Column count mismatch';
                return vals.map(v => v === '1' ? 1 : 0);
            });
        }

        applyTxtThreading.onclick = () => {
            // try {
            const grid = parse01Grid(txtThreading.value, SHAFTS, WARPS);

            for (let w = 0; w < WARPS; w++) {
                threading[w].fill(0);
                for (let s = 0; s < SHAFTS; s++) {
                    try {
                        if (grid[s][w]) {
                            threading[w][s] = 1;
                            break; // enforce one shaft per warp
                        }
                    }
                    catch (e) {

                    }
                }
            }

            buildThreading(threadingDiv);
            onDraftChange();
            // } catch (e) {
            //     alert('Invalid threading grid', e);
            // }
        };

        applyTxtTieup.onclick = () => {
            try {
                tieup = parse01Grid(txtTieup.value, SHAFTS, TREADLES);
                buildGrid(tieupDiv, SHAFTS, TREADLES, tieup);
                onDraftChange();
            } catch (e) {
                alert('Invalid tie-up grid');
            }
        };

        applyTxtTreadling.onclick = () => {
            try {
                treadling = parse01Grid(txtTreadling.value, PICKS, TREADLES);
                buildGrid(treadlingDiv, PICKS, TREADLES, treadling);
                onDraftChange();
            } catch (e) {
                alert('Invalid treadling grid');
            }
        };

        /* ================= INIT ================= */
        const threadingDiv = document.getElementById('threading');
        const tieupDiv = document.getElementById('tieup');
        const treadlingDiv = document.getElementById('treadling');
        const drawdown = document.getElementById('drawdown');

        buildThreading(threadingDiv);
        buildGrid(tieupDiv, SHAFTS, TREADLES, tieup);
        buildGrid(treadlingDiv, PICKS, TREADLES, treadling);
        drawDrawdown();

        /* ================= MQTT RECEIVE ================= */
        client.on('message', (topic, msg) => {

            if (topic == "weaving/draft/full") {
                const data = JSON.parse(msg.toString());
                if (!data.threading) return;

                threading = data.threading;
                tieup = data.tieup;
                treadling = data.treadling;

                buildThreading(threadingDiv);
                buildGrid(tieupDiv, SHAFTS, TREADLES, tieup);
                buildGrid(treadlingDiv, PICKS, TREADLES, treadling);
                drawDrawdown();
            }
            else if (topic == "/tc2/footswitch") {
                console.log("footswitch!")
                send_active();
                advance(1);
            }
        });
    </script>
</body>

</html>